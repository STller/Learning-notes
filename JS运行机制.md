线程与进程的区别

进程是操作系统分配资源的最小单位，线程是程序执行的最小单位

一个进程由一个或多个线程组成，线程可以理解为是一个进程中代码的不同执行路线

进程之间相互独立，但同一个进程下的各个线程间共享程序的内存空间（包括代码段、数据集、堆等）及一些进程级的资源

调度和切换：线程上下文切换比进程上下文切换要快得多

# 多进程和多线程

多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态

多线程指的是程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建国歌并行执行的线程来完成各自的任务

# 浏览器是多进程的

每打开一个tab页，就会产生一个进程，我们使用Chrome打开很多标签页不关，电脑会越来越卡，不说其他，首先就很耗CPU

# 浏览器包含那些进程

1. Browser进程：浏览器的主进程，负责协调、主控，该进程只有一个；负责浏览器界面显示，与用户交互。如前进、后退等；负责各个页面的管理，创建和销毁其他进程；将渲染进程得到的内存中的bitmap，绘制到用户界面上；网络资源的管理，下载等；
2. 第三方插件进程：每种类型的插件对应一个进程，当使用该插件时才创建
3. GPU进程：该进程也只有一个，用于3D绘制等
4. 渲染进程：即通常所说的浏览器内核（Renderer进程，内部是多进程）；每个Tab页面都是一个渲染进程，互不影响；主要作用为页面渲染，脚本执行，事件处理等；

# 为什么浏览器要多进程

假设浏览器是单进程，呐么某个tab页崩溃了，就影响了整个浏览器

同理如果某个插件崩溃了也会影响整个浏览器

# 渲染进程renderer的主要线程

1. GUI渲染线程

负责渲染浏览器界面，解析HTML，CSS，构建DOM树和renderObject树，布局和绘制等；解析html代码转化为浏览器认识的节点，生成DOM树，也就是DOM tree；解析css，生成cssom；把dom tree 和cssom结合，生成rendering tree

当我们修改了一些元素的颜色或者背景色，页面就会重绘（repaint）

当我们修改元素的尺寸，页面就会回流（reflow）

当页面需要repainting和reflow时GUI线程执行，绘制页面

回流比重绘的成本要高，我们要尽量避免reflow和repaint

GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行

2. JS引擎线程

JS引擎线程就是JS内核，负责处理JS脚本程序（例如V8引擎）

JS引擎线程负责解析JS脚本，运行代码

JS引擎一直等待着任务队列中任务的到来，然后加以处理；浏览器同时只能有一个JS引擎线程在运行JS程序，所以JS是单线程运行的；一个tab中（renderer）无论什么时候都只有一个JS线程在运行JS程序

GUI渲染线程与JS引擎线程是互斥的，JS引擎线程会阻塞GUI渲染线程；就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞；例如浏览器渲染的时候遇到script标签，就会停止GUI的渲染，然后JS引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。如果js执行时间太长，就会导致页面卡顿

3. 事件触发线程

属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列(task queue)

当js执行碰到事件绑定和一些异步操作(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理。

当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理

因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理

4. 定时器触发线程

`setInterval`与`setTimeout`所在线程

浏览器定时计数器并不是由JavaScript引擎计数的(因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)

通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程

W3C在HTML标准中规定，规定要求`setTimeout`中低于4ms的时间间隔算为4ms

5. 异步http请求线程

在XMLHttpRequest在连接后是通过浏览器新开一个线程请求

将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行

简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行

# 事件循环初探

定时触发线程只管理定时器且只关注定时不关心结果，定时结束就把回调扔给`事件触发线程`；

异步http请求线程只管理http请求同样不关心结果，请求结束把回调扔给`事件触发线程`；

事件触发线程只关心异步回调入事件队列；

而JS引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行；

这样反反复复就是所谓的`事件循环`；

# 宏任务（macrotask）&微任务（microtask）

1. 宏任务（macrotask）

在ECMAScript中，macrotask也被称为task

我们可以将每次执行栈执行的代码当作是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），每一个宏任务从头到尾执行完毕，不会执行其他

由于JS引擎线程和GUI渲染线程是互斥的关系，浏览器为了能够使宏任务和DOM任务有序的进行，会在一个宏任务执行结束后，在下一个宏任务执行前，GUI渲染线程开始工作，对页面进行渲染

常见的宏任务：主代码块；setTimeOut；setInterval；setImmediate-node；requestAnimationFrame-浏览器

宏任务-》GUI渲染任务-》宏任务。。。

2. 微任务（microtask）

ES6新引入了Promise标准，同时浏览器实现上多了一个microtask微任务概念，在ECMAScript中，microtask也被称为jobs

我们已经知道宏任务结束后会执行渲染，然后执行下一个宏任务，而微任务可以理解成在当前宏任务执行后立即执行的任务

当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完

常见的微任务：process.nextTick()-Node；Promise.then()；catch；finally；Object.observe；MutationObserver；

宏任务-》微任务-》GUI渲染任务-》宏任务。。。

# 事件循环例子

```javascript
setTimeout(function() {
    console.log('setTimeout');
})

new Promise(function(resolve) {
    console.log('promise');
}).then(function() {
    console.log('then');
})

console.log('console');
```

这段代码作为宏任务，进入主线程

先遇到setTimeOut，呐么将其回调函数注册后分发到宏任务Event Queue

接下来遇到了new promise立即执行，then函数分发到微任务Event Queue

遇到console log立即执行

整体代码script作为第一个宏任务执行结束，看看有哪些微任务，我们发现了then在微任务Event Queue里面，执行

第一轮事件循环结束，开始第二轮循环，当然要从宏任务Event Queue开始，我们发现了宏任务Event Queue中setTimeOut对应的回调函数，立即执行

结束
